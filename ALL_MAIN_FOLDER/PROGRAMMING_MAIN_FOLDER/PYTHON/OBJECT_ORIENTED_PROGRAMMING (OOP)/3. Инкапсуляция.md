### Private & Public

По умолчанию атрибуты в классах являются общедоступными (имеют доступ `Public`). Например:
```python
class FighterJet:  
    def __init__(self, display_name, max_speed):  
        self.display_name = display_name  
        self.max_speed = max_speed  
  
    def print_jet(self):  
        print(f"Название: {self.display_name}\nМакс. скорость: {self.max_speed}")  
  
f_14D = FighterJet("F-14D", 2.8)  
  
f_14D.print_jet()    # Название: F-14D  
                        # Макс. скорость: 2.8  

f_14D.max_speed = -87  
f_14D.print_jet()    # Название: F-14D  
                        # Макс. скорость: -87
```
*Но в данном случае мы можем, к примеру, присвоить скорости некорректное значение, например, указать отрицательное.*

Язык программирования `Python` позволяет определить **приватные** или **закрытые** атрибуты. Для этого имя атрибута должно начинаться с двойного подчеркивания - `__display_name`. Например, перепишем предыдущую программу, сделав оба атрибута - `display_name` и `max_speed` приватными:
```python
class FighterJet:  
    def __init__(self, display_name, max_speed):  
        self.__display_name = display_name  
        self.__max_speed = max_speed  
  
    def print_jet(self):  
        print(f"Название: {self.__display_name}\nМакс. скорость: {self.__max_speed}")  
  
f_14D = FighterJet("F-14D", 2.8)  
  
f_14D.print_jet()    # Название: F-14D  
                        # Макс. скорость: 2.8

f_14D.__max_speed = -87  
f_14D.print_jet()    # Название: F-14D  
                        # Макс. скорость: 2.8
```
*В принципе мы также можем попытаться установить для атрибута `__max_speed` новое значение:*
```python
f_14D.__max_speed = -87  
```

*Но вывод метода* `print_jet` *покажет, что атрибуты объекта не изменили свои значения:*
```python
f_14D.print_jet()       # Название: F-14D  
	                    # Макс. скорость: 2.8
```

Как это работает? При объявлении атрибута, имя которого начинается с двух прочерков, например, `__attribute`, Python в реальности определяет атрибут, который называется по шаблону `_ClassName__atribute`. То есть в случае выше будут создаваться атрибуты `_FighterJet__display_name` и `_FighterJet__max_speed`. Поэтому к такому атрибуту мы сможем обратиться только из того же класса. Но не сможем обратиться вне этого класса.

Например, присвоение значения этому атрибуту ничего не даст:
`f_14D.__max_speed = 43`
Потому что в данном случае просто определяется динамически новый атрибут `__max_speed`, но он не имеет ничего общего с атрибутом `self._FighterJet__max_speed`.

***А попытка получить его значение приведет к ошибке выполнения (если ранее не была определена переменная*** `__max_speed`***)***

Тем не менее приватность атрибутов тут довольно относительна. Например, мы можем использовать полное имя атрибута:
```python
class FighterJet:  
    def __init__(self, display_name, max_speed):  
        self.__display_name = display_name  
        self.__max_speed = max_speed  
  
    def print_jet(self):  
        print(f"Название: {self.__display_name}\nМакс. скорость: {self.__max_speed}")  
  
  
f_14D = FighterJet("F-14D", 2.8)  
  
f_14D.print_jet()       # Название: F-14D  
                        # Макс. скорость: 2.8  
f_14D._FighterJet__max_speed = -87  
f_14D.print_jet()       # Название: F-14D  
                        # Макс. скорость: -87
```
*Тем нее менее автор внешнего кода еще должен угадать, как называются атрибуты.*

### Методы доступа. Геттеры и сеттеры

**Геттер** позволяет получить значение атрибута, а **сеттер** установить его. Так, изменим выше определенный класс, определив в нем методы доступа:
```python
class FighterJet:  
    def __init__(self, display_name, max_cd):  
        self.display_name = display_name  
        self.__max_cd = max_cd  
  
    # сеттер для передачи сопротивления  
    def set_max_cd(self, max_cd):  
        if 0 < max_cd < 0.1:  
            self.__max_cd = max_cd  
        else:  
            self.__max_cd = None  
  
    # геттер для получения сопротивления  
    def get_max_cd(self):  
        return self.__max_cd  
  
    # метод вывода  
    def output(self):  
        print(f"display_name: {self.display_name} | max_cd: {self.__max_cd}")  
  
f_14B = FighterJet("F-14B", None)  
f_15E = FighterJet("F-15E", None)  

# точка входа
if __name__ == "__main__":  
    f_14B.set_max_cd(0.033) # Передача правильных значений  
    f_15E.set_max_cd(0.031) # Передача правильных значений  
  
    f_14B.output()          # display_name: F-14B | max_cd: 0.033  
    f_15E.output()          # display_name: F-15E | max_cd: 0.031  
  
    f_14B.set_max_cd(1)     # Передача неправильных значений  
    f_15E.set_max_cd(-10)   # Передача неправильных значений  
  
    f_14B.output()          # display_name: F-14B | max_cd: None  
    f_15E.output()          # display_name: F-15E | max_cd: None
```

### Аннотации свойств

Выше мы рассмотрели, как создавать методы доступа. Но `Python` имеет также еще один - более элегантный способ - **свойства**. Этот способ предполагает использование аннотаций, которые предваряются символом **@**.

Для создания свойства-геттера над свойством ставится аннотация `@property`.

Для создания свойства-сеттера над свойством устанавливается аннотация `имя_свойства_геттера.setter`.

Перепишем класс `FighterJet` с использованием аннотаций:
```python
class FighterJet:  
    def __init__(self, display_name, max_cd):  
        self.__display_name = display_name  
        self.__max_cd = max_cd  
  
    # геттер для получения сопротивления  
    @property  
    def max_cd(self):  
        return self.__max_cd  
  
    # сеттер для передачи сопротивления  
    @max_cd.setter  
    def max_cd(self, max_cd):  
        if 0 < max_cd < 0.1:  
            self.__max_cd = max_cd  
        else:  
            self.__max_cd = None  
  
    # геттер для получения названия  
    @property  
    def get_display_name(self):  
        return self.__display_name  
  
    # метод вывода  
    def output(self):  
        print(f"display_name: {self.get_display_name} | max_cd: {self.__max_cd}")  
  
  
f_14B = FighterJet("F-14B", None)  
f_15E = FighterJet("F-15E", None)  
  
# точка входа  
if __name__ == "__main__":  
    f_14B.max_cd = 0.033          # Передача правильных значений  
    f_15E.max_cd = 0.031          # Передача правильных значений  
  
    f_14B.display_name = "111111" # Попытка передачи неправильных значений  
    f_15E.display_name = "222222" # Попытка передачи неправильных значений  
  
    f_14B.output()                # display_name: F-14B | max_cd: 0.033  
    f_15E.output()                # display_name: F-15E | max_cd: 0.031  
  
    f_14B.max_cd = 1              # Передача неправильных значений  
    f_15E.max_cd = -10            # Передача неправильных значений  
  
    f_14B.output()                # display_name: F-14B | max_cd: None  
    f_15E.output()                # display_name: F-15E | max_cd: None
    
	f_14B.max_cd = 0.033          # Передача правильных значений  
	f_15E.max_cd = 0.031          # Передача правильных значений  
	  
	print(f_14B.max_cd)           # 0.033
```

Во-первых, стоит обратить внимание, что `свойство-сеттер` определяется после `свойства-геттера`.

Во-вторых, и `сеттер`, и `геттер` называются одинаково - `max_cd`. И поскольку `геттер` называется `max_cd`, то над `сеттером` устанавливается аннотация `@max_cd.setter`.

После этого, что к `геттеру`, что к `сеттеру`, мы обращаемся через выражение `f_14B.max_cd`.

При этом можно определить только `геттер`, как в случае с свойством `display_name` - его нельзя изменить, а можно лишь получить значение.