Наследование представляет из себя взятие методов и атрибутов дочерним (производным) классом от родительского (базового).
Синтаксис:
```python
class подкласс (суперкласс):
	методы_подкласса
```

Например есть класс `Engine`:
```python
class Engine:  
    def __init__(self, name, type):  
        self.__name = name  
        self.__type = type  
  
    @property  
    def name(self):  
        return self.__name  
  
    @property  
    def type(self):  
        return self.__type  
  
    def display_info(self):  
        print(f"Name: {self.__name}, Type: {self.__type}")
```

Создадим экземпляр для теста:
```python
f110 = Engine("f110-ge129", "turbofan")  

f110.display_info()        # Name: f110-ge129, Type: turbofan
```

Но нам нужно создать ещё один класс с похожим функционалом `CivilEngine`. И придётся переписывать весь функционал заново, дополняя существующий. В таком случае мы можем применить наследование.
Возьмём наш класс `Engine`:
```python
class Engine:  
    def __init__(self, name, type):  
        self.__name = name  
        self.__type = type  
  
    @property  
    def name(self):  
        return self.__name  
  
    @property  
    def type(self):  
        return self.__type  
  
    def display_info(self):  
        print(f"Name: {self.__name}, Type: {self.__type}")  
```

И заимствуем из него методы и параметры:
```python
class CivilEngine(Engine):  
  
    def forsage(self):  
        print(f"Name: {self.name}, Type: {self.type}, NO FORSAGE")
```
**!! ВАЖНО, В ДАННОМ ПРИМЕРЕ ПОКАЗАНО ЗАИМСТВОВАНИЕ ТОЛЬКО ЗАДАННЫХ ПАРАМЕТОВ ДЛЯ ИХ ПЕРЕОПРЕДЕЛЕНИЯ СПУСТИТЬСЯ НИЖЕ !!**

Теперь проверим:
```python
pw4000 = CivilEngine("pw4000-94", "turbofan")  
  
pw4000.forsage()        # Name: pw4000-94, Type: turbofan, NO FORSAGE
```

Так же можно выполнять множественное наследование (не допускать методов/атрибутов с одинаковыми именами).
```python
class Plane:  
    def fly(self):  
        print("Can flying")  
  
class Boat:  
    def swim(self):  
        print("Can swimming")  
  
  
class Seaplane(Plane, Boat):  
    pass  
  
l_31 = Seaplane()  
  
l_31.fly()      # Can flying  
l_31.swim()     # Can swimming
```

### Переопределение параметров класса (метод `super()`)

Возьмём родительский класс `FighterJet`:
```python
class FighterJet:  
    def __init__(self, name, engine):  
        self.__name = name  
        self.__engine = engine  
  
    @property  
    def name(self):  
        return self.__name  
  
    @property  
    def engine(self):  
        return self.__engine   
     
    def display_info(self):  
        print(f"Name: {self.__name}, Engine: {self.__engine}")
```


Теперь создадим класс `CivilAircraft` и наследуем `FighterJet`, но необходимо добавить параметр `count_passagers`. Для этого используем метод `super()` следующим образом:
```python
super().__init__(name, engine) 
```

Метод `super()` является обращением к родительскому классу из дочернего.
Теперь в `__init__` по мимо `count_passagers` запишем `name` и `engine`:
```python
class CivilAircraft(FighterJet):  
    def __init__(self, name, engine, count_passagers):  
        super().__init__(name, engine)  
  
        self.__count_passagers = count_passagers  
  
    @property  
    def count_passagers(self):  
        return self.__count_passagers  
   
    def display_info(self):  
        print(f"Name: {self.name}, Engine: {self.engine}, Count Pass: {self.__count_passagers}")
```

___

Весь код целиком выйдет:
```python
class FighterJet:  
    def __init__(self, name, engine):  
        self.__name = name  
        self.__engine = engine  
	
	#геттер названия самолёта
    @property  
    def name(self):  
        return self.__name  
	
	#геттер двигателя самолёта
    @property  
    def engine(self):  
        return self.__engine  
	
	#метод вывода info
    def display_info(self):  
        print(f"Name: {self.__name}, Engine: {self.__engine}")  
  
  
class CivilAircraft(FighterJet):  
    def __init__(self, name, engine, count_passagers):  
        super().__init__(name, engine)  
  
        self.__count_passagers = count_passagers  
	
	#геттер кол-во пассажиров
    @property  
    def count_passagers(self):  
        return self.__count_passagers  
	 
	#метод вывода info
    def display_info(self):  
        print(f"Name: {self.name}, Engine: {self.engine}, Count Pass: {self.__count_passagers}")  
  
# проверочные экземпляры
f_15E = FighterJet("F-15E", "f110-ge129")  
  
f_15E.display_info()        # Name: F-15E, Engine: f110-ge129

a_330 = CivilAircraft("A-330", "test_engine", 220)  
  
a_330.display_info()        # Name: A-330, Engine: test_engine, Count Pass: 220
```
