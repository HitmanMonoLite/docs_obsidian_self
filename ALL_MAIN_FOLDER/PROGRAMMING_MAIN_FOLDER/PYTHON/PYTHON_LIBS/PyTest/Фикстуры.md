Фикстура, грубо говоря это предисловие или постусловие. Необходима для подготовки к выполнению сценария тестирования. Например для создания переменной, списка, открытия или создания файла и т.п.
  
После использования декоратора `@pytest.fixture` мы объявляем функцию.  
например так:  
```python
@pytest.fixture  
def order(first_entry):  
    return []  
```
  
То есть в `order` у нас находится пустой список. И в последствии выполнения сценария тестирования мы можем к нему обращаться и например складывать туда какие либо объекты: 
```python
import pytest  
  
@pytest.fixture  
def first_entry():  
    return "any text"
  
@pytest.fixture  
def order(first_entry):  
    return []  
  
@pytest.fixture(autouse=True)  
def append_first(order, first_entry):  
    return order.append(first_entry)  
  
def test_string_and_int(order, first_entry):  
    order.append(2)  
    assert order == [first_entry, 2]
```
  
В данном случае я объявил `first_entry` что возвращает `"any text"` и добавил этот объект в `order`. Потом в процессе тестирования добавил в `order` 2.
После проверил оба ли объекта находятся в `order`.
  
*`autouse` это "приспособление" (как написано в оф. доке) для автоматического использования. Т.е. по сути `pytest` автоматически выполнил `order.append(first_entry)` во время тестирования функции `test_string_and_int()`.*

---

==scope==

Настройка области действия.
Принимает параметры:

`scope='function'`
Выполняется один раз для каждой функции теста. Часть `setup` запускается перед каждым тестом с помощью `fixture`. Часть `teardown` запускается после каждого теста с использованием `fixture`. 
**Эта область используемая по умолчанию, если параметр scope не указан.**

`scope='class'`
Выполняется один раз для каждого тестового класса, независимо от количества тестовых методов в классе.

`scope='module'`
Выполняется один раз для каждого модуля, независимо от того, сколько тестовых функций или методов или других фикстур при использовании модуля.

`scope='session'`
Выполняется один раз за сеанс. Все методы и функции тестирования, использующие фикстуру области сеанса, используют один вызов `setup` и `teardown`.

**Логика работы**

Пример кода:
```python
# Demo fixture scope.  
import pytest  
  
@pytest.fixture(scope='function')  
def func_scope():  
    # A function scope fixture.  
  
@pytest.fixture(scope='module')  
def mod_scope():  
    # A module scope fixture.  
  
@pytest.fixture(scope='session')  
def sess_scope():  
    # A session scope fixture.  
  
@pytest.fixture(scope='class')  
def class_scope():  
    # A class scope fixture.  
  
def test_1(sess_scope, mod_scope, func_scope):  
    # Тест с использованием сессий, модулей и функций.  
  
def test_2(sess_scope, mod_scope, func_scope):  
    # Демонстрация более увлекательна со множеством тестов.  
  
@pytest.mark.usefixtures('class_scope')  
class TestSomething():  
    # Demo class scope fixtures.  
  
    def test_3(self):  
        # Test using a class scope fixture.  
  
    def test_4(self):  
        # Again, multiple tests are more fun.
```

Давайте используем `--setup-show` для демонстрации, что количество вызовов fixture и setup в паре с teardown выполняются в зависимости от области:
```
$ cd /path/to/code/ch3/
$ pytest --setup-show test_scope.py
============================= test session starts =============================

collected 4 items

test_scope.py
SETUP    S sess_scope
    SETUP    M mod_scope
        SETUP    F func_scope
        test_scope.py::test_1 (fixtures used: func_scope, mod_scope, sess_scope).
        TEARDOWN F func_scope
        SETUP    F func_scope
        test_scope.py::test_2 (fixtures used: func_scope, mod_scope, sess_scope).
        TEARDOWN F func_scope
      SETUP    C class_scope
        test_scope.py::TestSomething::()::test_3 (fixtures used: class_scope).
        test_scope.py::TestSomething::()::test_4 (fixtures used: class_scope).
      TEARDOWN C class_scope
    TEARDOWN M mod_scope
TEARDOWN S sess_scope

========================== 4 passed in 0.11 seconds ===========================
```

---

Рассмотрим две возможности интеграции в код:

Первый вариант через `conftest.py`.
1. Создать файл с именем `conftest.py` в директории, где находятся ваши тестовые файлы или в родительской директории.
2. В файле `conftest.py` обозначить фикстуры и импортировать сам модуль pytest.
   Например так:
   ```python
	import pytest  
  
	@pytest.fixture  
	def my_fixture(request):  
	    val = request.param  
	    return val * 2
	```
	
*файл* `conftest.py`
*модуль увидит файл и самостоятельно добавит фикстуры в процесс тестирования*

---

Второй вариант, нативно, просто прописав их в основном файле теста.
Например так:
```python
import pytest  
  
@pytest.fixture  
def my_fixture(request):  
    val = request.param  
    return val * 2  
  
@pytest.mark.parametrize("my_fixture", [1, 2, 3], indirect=True)  
def test_indirect(my_fixture):  
    assert my_fixture in [2, 4, 6]
```