Замыкание (closure) или фабричная функция - это функция определяемая и возвращаемая другой функцией, при этом замыкание получает доступ к значениям и объектам в области видимости "родительской" (или объемлющей) функции независимо от того из какой области видимости происходит вызов замыкания.

```python
def outers():     
	n = 2    
	
	def closure():         
		return n ** 2     
	return closure
	
closure_foo = outers()      # Вызываем внешнюю функцию, возвращаемая функция (замыкание) присваивается переменной 

print(closure_foo)          # <function outers.<locals>.closure at 0x7f254d6fe170> num = closure_foo()         # Вызываем замыкание, результат присваивается переменной 

print(num)                  # 4 # Второй вариант вызова замыкания 
print(outers()())           # 4
```

Скобки после имени функции говорят интерпретатору о том, что ее необходимо вызвать. После вызова `outers()`, на ее место возвращается замыкание `closure`, к которому добавляется оставшаяся пара скобок. Замыкание вызывается, возвращая на свое место результат.

_______________
```python
def multiplier(factor):    
	
	def closure(x):        
		return factor * x    
	return closure
	
double = multiplier(2)
triple = multiplier(3)

print(double(5))  # 10 результат аналогичен вызову multiplier(2(5)
print(triple(4))  # 12 результат аналогичен вызову multiplier(3)(4)
```

В данном примере механизм замыканий используется для определения нескольких схожих функций (double и triple), что позволяет избежать дублирования кода. Кроме того, этот пример призван продемонстрировать, что разные экземпляры одного замыкания будут иметь доступ к разным значениям из области видимости родительской функции.

Базовый пример замыкания:
![[Pasted image 20250623152157.png]]

_______________________

**ВАЖНО!** 
**Замыкания позволяют запоминать значения и использовать их в последующих вычислениях.**

``` python
# Чистая функция - просто сортирует задачи по приоритету
def sort_tasks(tasks):
    return sorted(tasks, key=lambda x: x["priority"], reverse=True)


# Замыкание - хранит задачи и позволяет управлять ими
def create_task_manager():
    tasks = []  # хранилище задач в замыкании

    def manage(action, task=None):
        if action == "add" and task:
            tasks.append(task)
        elif action == "remove" and task:
            tasks.remove(task)
        elif action == "clear":
            tasks.clear()
        elif action == "get_high_priority":
            return [t for t in tasks if t["priority"] >= 8]

        return sorted(tasks, key=lambda x: x["priority"], reverse=True)

    return manage


# Чистая функция - каждый раз новый результат
tasks_list = [{"name": "Task 1", "priority": 5}, {"name": "Task 2", "priority": 9}]
print(sort_tasks(tasks_list))  # всегда один и тот же вывод для одних и тех же данных

# Замыкание - хранит состояние и позволяет редактировать список задач
manager = create_task_manager()
print(
    manager("add", {"name": "Task 1", "priority": 5})
)  # [{'name': 'Task 1', 'priority': 5}]
print(
    manager("add", {"name": "Task 2", "priority": 9})
)  # [{'name': 'Task 2', 'priority': 9}, {'name': 'Task 1', 'priority': 5}]
print(manager("get_high_priority"))  # [{'name': 'Task 2', 'priority': 9}]
print(manager("clear"))  # []
```

Замыкания, как и декораторы, позволяют нам создавать на базе функций собственные объекты и систему управления ими.